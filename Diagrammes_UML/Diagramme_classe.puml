@startuml JeuDeLaVie

skinparam classAttributeIconSize 0
skinparam packageStyle rectangle
skinparam linetype ortho

' ===== PACKAGE: Components/Cell =====
package "Components::Cell" #LightBlue {
    abstract class CellState {
        + {abstract} isAlive() : bool
        + {abstract} clone() : unique_ptr<CellState>
    }
    
    class AliveState {
        + isAlive() : bool
        + clone() : unique_ptr<CellState>
    }
    
    class DeadState {
        + isAlive() : bool
        + clone() : unique_ptr<CellState>
    }
    
    class Cell {
        - state : unique_ptr<CellState>
        + Cell(CellState*)
        + isAlive() : bool
        + setState(CellState*) : void
    }
    
    CellState <|-- AliveState
    CellState <|-- DeadState
    Cell *-- CellState
}

' ===== PACKAGE: Components/Rules =====
package "Components::Rules" #LightGreen {
    abstract class Rules {
        + {abstract} willBeAlive(bool, int) : bool
    }
    
    class StandardRule {
        + willBeAlive(bool, int) : bool
    }
    
    Rules <|-- StandardRule
}

' ===== PACKAGE: Components/Grid =====
package "Components::Grid" #LightYellow {
    class Grid {
        - width : int
        - height : int
        - cells : vector<vector<Cell>>
        + Grid(int, int)
        + setAlive(int, int) : void
        + setDead(int, int) : void
        + toggleCell(int, int) : void
        + getCell(int, int) : Cell&
        + countLivingNeighbours(int, int) : int
        + swap(Grid&) : void
    }
    
    Grid *-- Cell
}

' ===== PACKAGE: Services =====
package "Services" #PaleGreen {
    class WorkerPool {
        + getInstance() : WorkerPool&
        + enqueue(function) : void
    }
}

' ===== PACKAGE: Components/Updaters =====
package "Components::Updaters" #Plum {
    abstract class GridUpdater {
        + {abstract} update(Grid&, const Rules&) : void
        + {abstract} getName() : string
    }

    class SingleThreadUpdater {
        + update(Grid&, const Rules&) : void
    }

    class MultiThreadUpdater {
        + update(Grid&, const Rules&) : void
    }

    GridUpdater <|-- SingleThreadUpdater
    GridUpdater <|-- MultiThreadUpdater
    GridUpdater ..> Grid
    GridUpdater ..> Rules
    MultiThreadUpdater ..> WorkerPool : <<uses>>
}

' ===== PACKAGE: Components =====
package "Components" #Wheat {
    class Game {
        - grid : Grid
        - rule : const Rules&
        - updater : unique_ptr<GridUpdater>
        - iterations : int
        + Game(Grid, Rules&, int, unique_ptr<GridUpdater>)
        + nextStep() : void
        + print() : void
    }
    
    Game *-- Grid
    Game --> Rules
    Game *-- GridUpdater
}

' ===== PACKAGE: Services/IO =====
package "Services::IO" #LightCoral {
    class FileReader {
        + read(string) : Grid
    }
    
    class FileWriter {
        + write(Grid, string) : void
    }
    
    class FileName {
        + generateOutputName(string, int) : string
    }
    
    class FolderManager {
        + createOutputFolder(string) : void
    }
    
    FileReader ..> Grid : <<creates>>
    FileWriter ..> Grid : <<reads>>
}

' ===== PACKAGE: Services (Runner) =====
package "Services " as ServicesRunner #PaleGreen {
    class GameRunner {
        + run() : void
    }
    
    GameRunner ..> FileReader
    GameRunner ..> FileWriter
    GameRunner ..> Game
}

' ===== PACKAGE: Ihm =====
package "Ihm" #Lavender {
    class GameWindow {
        - grid : Grid&
        - rule : const Rules&
        - updater : unique_ptr<GridUpdater>
        + GameWindow(Grid&, Rules&, unique_ptr<GridUpdater>)
        + run() : void
        - update() : void
        - drawGrid() : void
    }
    
    GameWindow --> Grid
    GameWindow --> Rules
    GameWindow *-- GridUpdater
}

@enduml